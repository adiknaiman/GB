#include <stdio.h>

//1. Реализовать обход в глубину с использованием стека

const int n = 6;
int matrix[n][n] = {
    {0, 1, 1, 0, 0, 0},
    {0, 0, 0, 1, 1, 1},
    {0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 1, 0},
}
int visited[n] = { 0 };

void depthTravers(int) {
    int r;
    printf("$d", st);

    visited[st] = 1;
    for (r = 0; r < n; ++r) {
        if (matrix[st][r] == 1 && !visited[r]) {
            depthTravers(r);
        }
    }
}

void reserArr() {
    for (int i = 0; i < n; ++i) {
        visited[i] = 0;
    }
}





//2. Моделируем робот поисковой системы. Дан готовый простой граф с циклическими связями. 
//   Нужно обойти этот граф двумя способами и подсчитать количество ссылок на каждый из узлов графа (полустепень захода).
//   обход графа рекурсивной функцией(с подсчётом только смежных со стартовой вершин)
//   обход графа по матрице смежности(с подсчётом всех вершин графа) В конце обхода вывести два получившихся списка всех узлов 
//   в порядке уменьшения количества ссылок на них.

int main() {
    printf("\n---------------------------------------------------\n\n");
    //1. Реализовать обход в глубину с использованием стека
    depthTravers(0);
    resetArr();
    printf("\n");
    depthTravers(2);
    resetArr();
    printf("\n");
    depthTravers(1);
    resetArr();
    printf("\n");


    printf("\n---------------------------------------------------\n\n");

    //2. Моделируем робот поисковой системы. Дан готовый простой граф с циклическими связями. 
    //   Нужно обойти этот граф двумя способами и подсчитать количество ссылок на каждый из узлов графа (полустепень захода).
    //   обход графа рекурсивной функцией(с подсчётом только смежных со стартовой вершин)
    //   обход графа по матрице смежности(с подсчётом всех вершин графа) В конце обхода вывести два получившихся списка всех узлов 
    //   в порядке уменьшения количества ссылок на них.

    printf("\n\n---------------------------------------------------\n\n");

    return 0;
}
